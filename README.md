# Решатель Ньютона - Рафсона для решения систем нелинейных уравнений фиксированный размерности

Данный солвер решает систему нелинейных уравнений заранее известной (фиксированной) размерности с помощью алгоритма Ньютона-Рафсона.
Особенностью данного солвера является учет фиксированности размерности, который позволяет не использовать динамическую память для хранения векторов.

## Оглавление
* [Сборка библиотеки под CMake](#Сборка)
* [Назначение библиотеки](#Назначение-библиотеки)
  * [Метод Ньютона - Рафсона](#Метод-Ньютона---Рафсона)
  * [Учебный пример](#Учебный-пример)
  * [Использование бибилотеки](#Использование-бибилотеки)
* [Инициализация системы нелинейных уравнений (fixed_system.h)](#fixed_system.h)
* [Решатель Ньютона - Рафсона (fixed_nonlinear_solver.h)](#fixed_nonlinear_solver.h)


## Сборка

 Для работы с данной бибилиотекой необходимо собрать её при помощи CMake. Инструкция для сборки под MSVC находится по пути [msvc_cmake/readme.txt](msvc_cmake/readme.txt)

## Назначение библиотеки

### Метод Ньютона - Рафсона

Метод Ньютона - Рафсона - это итерационный чисенный метод нахождения корня уравнения (системы уравнений). Поиск решения осуществляется путём построения последовательных приближений.

### Учебный пример

Рассмотрим простейший пример использования данной библиотеки на примере следующей системы уравнений: 

```math
  \begin{cases}
    (x_{1} - 2)^{3} = 8 \\ (x_{2} - 1)^{3} = 27
  \end{cases}
```
Для решения этой системы уравнений с помощью решателя Ньютона - Рафсона, необходимо получить вектор уравнений невязок. Для данной системы уравнений вектор невязок это будет выглядеть следующим образом:
```math
  \overline{r}(x)
  = 
  \begin{cases}
    (x_{1} - 2)^{3} - 8 \\ (x_{2} - 1)^{3} - 27
  \end{cases} 
```
Затем численный метод будет искать значение $x$, которое удовлетворит $\overline{r}(x) = \overline{0}$. <br />
Ввиду сложности системы нелинейных уравнений  $\overline{r}(x)$, мы не можем решить задачу отыскания $x$, однако мы можем решить линеаризованную задачу отыскания $\Delta x$ на каждой итерации $M_{k}(\Delta x)$:
```math
  \Delta x_{k+1} = -J^{-1}(x_{k}) \bullet r(x_{k})
```
где: <br /> $M_{k}(\Delta x)$ - линеаризованная модель, которая описывает поведение $\overline{r}(x)$ в окрестности текущего приближения численного метода <br />
$J(x_{k})$ - Якобиан <br />
Соответственно, новое текущее приближение будет следующим:
```math
  x_{k+1} = x_{k} + \Delta x_{k+1}
```
Однако, были приведены синтетические примеры, при которых, при соблюдении критериев применимости решателя Ньютона, алгоритм не сходится. Для решения этой проблемы применяется усовершенствованный метод Ньютона - Рафсона, в котором новое текущее приближения считается следующим образом:
```math
  x_{k+1} = x_{k} + \alpha \bullet \Delta x_{k+1}
```

**Реализация данной задачи с помощью данной бибилотеки будет выглядеть следующим образом:**

```C++
// Подключение бибилиотеки
// Класс, для системы размерности <2> - Векторный случай
// <2> - Размерность системы уравнений
class sample_system : public fixed_system_t<2>
{
    using fixed_system_t<2>::var_type;
public:
    // Задание функции невязок
    var_type residuals(const var_type& x) {
        return
        {
            pow(x[0] - 2, 3) - 8.0,
            pow(x[1] - 1, 3) - 27.0
        };
    }
};
   
// Создание экземпляра класса, который и будет решаемой системой
sample_system test;
// Задание настроек решателя по умолчанию
fixed_solver_parameters_t<2, 0> parameters;
// Создание структуры для записи результатов расчета
fixed_solver_result_t<2> result;
// Решение системы нелинейныйх уравнений <2> с помощью решателя Ньютона - Рафсона
// { 0, 0 } - Начальное приближение
fixed_newton_raphson<2>::solve_dense(test, { 0, 0 }, parameters, & result);
```
### Использование бибилотеки

Для использования данной бибилотеки необходимо задать следующие "входные" параметры для решателя Ньютона - Рафсона:
**Обязательно**
* Размерность системы уравнений 
* Функция невязок
* Параметры решателя (задаются по умолчанию, при желании можно настроить самостоятельно)
* Структура для формирования ответа
* Начальное приближение

**Необязательно**
* Задание расчета Якобиана. В бибилотеке по умолчанию реализован численный расчет Якобиана, однако при наличии аналитического решения, его можно реализовать в решателе

<div align="center">
</center><h2>Структура библиотеки</h2></center>
</div>

<pre>
├───fixed
│   │   array_ext.h - Дополнительные матричные операции
│   │   fixed.h - Этот файл надо подключить для использований функций библиотеки
│   │   fixed_linear_solver.h - Решатель системы линейных уравнений
│   │   fixed_nonlinear_solver.h - Решатель системы НЕлинейных уравнений
│   │   fixed_system.h - Специализации систем различной размерности
│   │
│   └───line_search - Алгоритмы линейного поиска
│           divider.h - Линейный поиск методом дробления шага
│           golden_section.h - Линейный поиск методом золотого сечения
</pre>

<div align="center">
</center><h2>fixed_system.h</h2></center>
</div>

Данный *.h* файл представляет собой структуры с помощью которых можно задать системы нелинейных уравнений фиксированной размерности с помощью массиовов, что позволяет не использовать динамическую память для хранения векторов.

<div align="center">
  
|Тип системы нелинейных уравнений|Размерность|
|:----:|:----------:|
|Скалярный случай|<1>|
|Векторный случай|<*n*>|

</div>

Также здесь реализованы:
1. Численный расчет Якобиана для скалярного и векторного случая 
2. Расчет целевой функции методом суммы квадратов 

<div align="center">
</center><h2>fixed_nonlinear_solver.h</h2></center>
</div>

В данном *.h* файле реализован алгоритм Ньютона - Рафсона. С помощью которого решается заданная система нелинейных уравнений. Код представляет выбор метода линейного поиска:
1. Линейный поиск методом золотого сечения 
2. Линейный поиск методом дробления шага 

Настройка, анализ и результат работы алгоритма реализован с помощью следующих структур:

<div align="center">
  
|Название структуры|Свойства|
|:----:|:----------:|
|<fixed_solver_parameters_t>|В данной структуре задаются настроечные параметры алгоритма|
|<fixed_solver_result_t>|В данную структуру записывается результат работы решателя|
|<fixed_solver_result_analysis_t>|В данную структуру записывается анализ работы решателя|
|<fixed_solver_constraints>|В данной структуре задаются ограничения для решателя|

</div>


